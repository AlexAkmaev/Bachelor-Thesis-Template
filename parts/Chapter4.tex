\section{Описание практической части}
\label{sec:Chapter4} \index{Chapter4}

В нашей практической части исследования мы столкнулись с необходимостью внедрения объединённых типов в существующий
проект по разработке статически типизированного языка программирования MyTS\@.
Развитие статически типизированных языков программирования продолжает оставаться актуальной темой, поскольку такие
языки предлагают ряд преимуществ, таких как повышение надёжности и обеспечение более строгой документации кода.
При разработке статически типизированных языков программирования одним из ключевых аспектов является поддержка
различных типов данных и их комбинаций.
Объединённые типы предоставляют механизм для определения переменных, которые могут содержать значения различных типов.
Это позволяет программистам более гибко и эффективно работать с данными в коде, обеспечивая при этом строгую типизацию
и избегая возможных ошибок времени выполнения.

В данном проекте нам требовалось внедрить поддержку объединённых типов для расширения возможностей системы типов языка
программирования.
В предыдущей главе мы исследовали различные сценарии использования типов объединения в нашем языке, изучили внутреннее
устройство компилятора, а также необходимые сторонние механизмы (такие как boxing/unboxing операции и инструкции
загрузки по имени), которые потребуются нам для реализации решения.

На верхнем уровне нам необходимо внедрить наше решение в парсер (синтаксический анализатор), механизм проверки типов и
кодогенерации.
При необходимости воспользуемся отдельными проходами для модификации AST дерева.
Все ключевые алгоритмы ниже будут представлены на псевдокоде в демонстрационных целях.

\subsection{Синтаксический анализ}

Основная функция, которая парсит пришедший нам union тип, представлена следующим псевдокодом:

\begin{lstlisting}
Function ParseUnionType(FirstType):
    types = []
    types.append(FirstType)
    while NextToken() == "|":
        ReadNextToken()
        nextType = ParseTypeAnnotation()
        types.append(nextType)
    unionType = CreateUnionType(types)
    startPosition = StartPositionOfFirstType(FirstType)
    endPosition = EndPositionOfLastType(types)
    SetRangeOfUnionType(unionType, startPosition, endPosition)
    return unionType
\end{lstlisting}

Функция начинается с создания вектора типов types, который будет содержать все типы, входящие в объединённый тип.
Первый тип в объединении добавляется в вектор types.
Затем функция переходит в цикл while, который продолжается, пока текущий токен - это побитовый оператор "ИЛИ" (|).
Внутри цикла функция считывает следующий токен (переход к следующему токену).
Затем она вызывает функцию ParseTypeAnnotation, которая парсит следующий тип, на который указывает токен после
оператора "ИЛИ", и добавляет его в вектор types.
Наконец, после выхода из цикла создаётся объект unionType, представляющий объединённый тип, и инициализируется с
использованием вектора типов types.
Затем устанавливается диапазон объединённого типа от начальной позиции (локации первого типа в исходном коде)
до конечной позиции последнего типа в объединении.
Наконец, функция возвращает указатель на созданный объект unionType, который является уже частью внутреннего
представления программы.

\subsection{Анализатор типов}

Проверка типов является одним из основных этапов компилятора и происходит после создания синтаксического анализа и
построения AST дерева.
В анализаторе типов представлены главные структуры промежуточного представления для всех узлов дерева и типов
переменных.
Нам необходимо написать свой класс для union типа с необходимым функционалом для анализа и дальнейшей кодогенерации.
Этот класс должен поддерживать следующую функциональность, как и все остальные типы анализатора:

\begin{itemize}[left=2em]
    \item Отношение идентичности объединения другому типу
    \item Отношение подтипирования
    \item Отношение присвоения
    \item Отношение приведения
\end{itemize}

Кроме того, необходимо переопределить много других вспомогательных функций (например строковое представления для
вывода ошибок или ассемблерное представление для кодогенерации), а также продумать формат, в котором приходят и
обрабатываются наши компоненты объединения.

Было принято решение, что удобнее всего передавать в этот класс уже нормализованные типы, так как логически
нормализация должна происходить сразу при создании объединения.
Также после нормализации в конструкторе класса будет вычисляться низкоуровневое представление union типа, которое
впоследствии будет использоваться в среде исполнения.
Для качественной и честной кодогенерации представлять объединение на уровне байт-кода было бы правильным подходом.
Однако ввиду срочности производственной задачи было принято решение реализовать более простой вариант низкоуровневого
представления, а именно с помощью наименьшей верхней границы.
Дадим ее определение.

\subsubsection{Hаименьшая верхняя граница}

Понятие наименьшей верхней границы (LUB - least upper bound) используется там, где необходимо найти единственный тип,
который является общим супертипом для набора ссылочных типов.
Слово "наименьший" означает, что необходимо найти наиболее специфичный супертип, и не существует другого общего
супертипа, который был бы подтипом LUB\@.
Отдельный тип является наименьшей верхней границей сам по себе.
В наборе \hl{($A_1$,. . . , $A_n$)}, который содержит по меньшей мере два типа, LUB определяется следующим образом:

\begin{itemize}[left=2em]
    \item Для каждого типа в наборе определяется свой набор супертипов $SupA_i$;
    \item Вычисляется пересечение наборов $SupA_i$.
    Пересечение всегда содержит объект и, следовательно, не может быть пустым.
    \item Из пересечения выбирается наиболее специфичный тип.
\end{itemize}

Ошибка времени компиляции возникает, если какие-либо типы в исходном наборе \hl{($A_1$,. . . , $A_n$)}
не являются ссылочными типами.

\subsubsection{Алгоритм подсчета низкоуровневого представления объединения}

Низкоуровневое представление объединения необходимо для кодирования union типов в байт-код и вычисляется в основном
с использованием наименьшей верхней границы.

\begin{lstlisting}[label={lst:computelub}]
Function ComputeLowLvlType(unionType):
    preciseType = GetPreciseType(unionType)
    If preciseType is not UnionType:
        return preciseType
    lub = null
    For each type in unionType.ConstituentTypes():
        If type is NullType or lub == type:
            continue
        If lub is null:
            lub = type
            continue
        If type is ObjectType and lub is ObjectType:
            lub = GetLUB(lub.AsObjectType(), type.AsObjectType())
        Else If type is PrimitiveType:
            If lub is ObjectType:
                lub = GetLUB(lub.AsObjectType(), ConvertToObjectType(type))
            Else If lub is PrimitiveType:
                lub = LargestPrimitive(type, lub)
            Else:
                return GetGlobalObjectType()
        Else:
            return GetGlobalObjectType()
    return GetNonConstantType(lub)
\end{lstlisting}

Низкоуровневое представление может являться как ссылочным типом, так и примитивным.
Это было сделано для оптимизации объединений, содержащих литеральные типы, и будет описано подробнее в последующих
разделах.

Итак, выше на псевдокоде приведена функция вычисления нашего представления объединения и ее можно описать следующим
образом:
\begin{itemize}[left=2em]
    \item Сначала определяется наиболее точный тип для объединения.
    Наиболее точный тип определяется либо самим типом объединения, либо ограничением на типовой параметр.
    Если этот тип не является union типом, он возвращается как есть
    \item Далее инициализируется переменная lub (наименьшая общая верхняя граница) как null
    \item После чего мы входим в цикл, который перебирает все составляющие типы объединения
    \item Если текущий тип является NullType или равен lub, то он пропускается
    \item Если lub еще не установлен, он инициализируется текущим типом и продолжается следующая итерация
    \item Если оба типа (текущий и lub) являются ObjectType, определяется их наименьшая общая верхняя граница с
    помощью функции GetLUB\@.
    \item Если текущий тип является PrimitiveType, выполняются дальнейшие проверки:
    \begin{itemize}[left=2em]
        \item Если lub является ObjectType, определяется наименьшая общая верхняя граница между lub (как ObjectType) и
        текущим типом, преобразованным в ObjectType.
        \item Если lub также является PrimitiveType, вызывается функция LargestPrimitive для определения наибольшего
        примитивного типа между текущим типом и lub.
        \item В противном случае, возвращается глобальный объектный тип.
    \end{itemize}
    \item Если текущий тип не соответствует ни одному из вышеуказанных условий, возвращается глобальный объектный тип
    \item В конце, возвращается не константный тип, который является наименьшей общей верхней границей для всех
    составляющих типов union.
\end{itemize}
Возвращается именно не константное значение, потому что на уровне байт-кода нет представления для литералов.
Также низкоуровневое представление будет потом участвовать в кодогенерации и проходах по модификации AST дерева,
как примитивный тип.

\subsubsection{Алгоритм нормализации объединения}

Процесс нормализации объединения происходит в самом начале даже перед подсчетом низкоуровневого представления.
Ввиду сложности, рассмотрим алгоритм нормализации в несколько этапов, постепенно погружаясь во все более вложенные
функции.

Дадим определение нескольких небольших функций, участвующих в алгоритме:

\begin{itemize}[left=2em]
    \item Функция IsNumericUnion, определяющая, что union тип является числовым, возвращает истину в том случае, если все
составляющие типы объединения являются маленькими (unboxed) числовыми типами или числовыми литералами.
В противном случае функция возвращает ложь.
    \item Функция BoxTypes, как видно из названия, преобразует все компоненты объединения в большие (boxed) типы.
    \item Функция TryAbsorbType пытается слить воедино два типа, которые в нее пришли.
    Делает она это путем вызова функции подтипирования для обоих типов, а также довольно непростого анализа удаления
    литеральных типов, который будет описан чуть позже.
\end{itemize}

Далее опишем алгоритм линеаризации и удаления идентичных типов на псевдокоде:

\begin{lstlisting}[label={lst:normalization}]
    initialSize = len(types)
    for i from 0 to initialSize - 1:
        currentType = types[i]
        if currentType is UnionType:
            otherTypes = currentType.ConstituentTypes()
            add otherTypes to types
            types[i] = null
        else if currentType is NeverType:
            types[i] = null
    EliminateAllNullTypes(types)
    if not IsNumericUnion(types):
        BoxTypes(types)
    for each cmp in types:
        for each it from cmp + 1 to end of types:
            merged = TryAbsorbType(cmp, it)
            if merged is not null:
                if merged == cmp:
                    remove it from types
                else:
                    remove cmp from types
                    cmp = next element after cmp
            else:
                continue to next it
\end{lstlisting}

В результате работы этого алгоритма получается более оптимизированный и компактный union тип, который может
использоваться в дальнейших вычислениях и проверках типов.
Опишем подробнее, какие шаги присутствуют в написанном коде:

\begin{itemize}[left=2em]
    \item Линеаризация: Развертывание всех вложенных union типов и удаление типов never.
    Для каждого элемента в списке types:
    \begin{itemize}[left=2em]
        \item Если элемент является union типом, его составляющие типы добавляются в конец списка types.
        \item Если элемент является типом never, он помечается как null.
    \end{itemize}
    Стоит отметить, что рекурсивно раскрываются все вложенные объединения, так как если union тип попал в алгоритм
    нормализации, значит он был уже кем-то создан.
    А как известно еще перед созданием объединения все типы, которые в него поступают, проходят такой же процесс линеаризации.

    \item Далее удаляются все null элементы из списка types, которые были помечены ранее.
    Также размер списка types уменьшается до количества всех не null элементов.
    \item Boxing типов: Если union не состоит из числовых типов, вызывается функция BoxTypes, описанная ранее.
    \item Слияние подтипов: Итерация по каждому элементу в списке types.
    Для каждого элемента проверяются все последующие элементы на возможность слияния с помощью функции TryAbsorbType.
    Если два элемента могут быть объединены, выполняется их слияние:
    \begin{itemize}[left=2em]
        \item Если слияние возвращает первый элемент, второй элемент удаляется.
        \item Если слияние возвращает второй элемент, первый элемент удаляется, и текущая итерация смещается на
        следующий элемент после текущего.
    \end{itemize}
\end{itemize}

В более подробном объяснении нуждается процесс слияния литеральных типов, поскольку спецификацией задается требование,
что любое значение литерала, попадающее в более расширенный числовой тип, удаляется из объединения.
На практике для каждого примитивного типа у нас существует отдельный класс для анализатора типов со своими отношениями
подтипирования и идентичности.
В этих отношениях в рамках одного примитивного класса невозможно обрабатывать все другие примитивные классы из-за
громоздкости и возможных конфликтов с другими компонентами анализатора.
Поскольку данные правила подтипирования и удаления литералов задействованы только в объединениях, то логично реализовать
необходимый функционал на месте и сделать его частью класса анализатора union.

Следующий псевдокод описывает алгоритм проверки, может ли константный литерал быть присвоен целевому типу в union типе.
Алгоритм включает несколько этапов: проверку типов константы и целевого типа, проверку идентичности типов и проверку
соответствия константы целевому типу:

\begin{lstlisting}[label={lst:literalassignable}]
Function IsLiteralAssignableTo(literal, target):
    if target == GlobalObjectType:
        return true
    if literal is StringType:
        return target is StringType and
                (not target is LiteralType or IsIdentical(literal, target))
    if literal is BigIntType:
        return target is BigIntType and
                (not target is LiteralType or IsIdentical(literal, target))
    if not target is PrimitiveType:
        if target is UnboxableObject:
            target = ToPrimitiveType(target)
        else:
            return false
    return IsIdentical(literal, target) or IsLiteralFitsToType(literal, target)
\end{lstlisting}
Опишем шаги из псевдокода подробнее:

\begin{itemize}[left=2em]
    \item Если target является глобальным объектным типом, возвращается true, так Object является доминирующим типом
    над любой компонентой объединения. 
    \item Обработка строковых литералов: Если literal имеет тип StringType, проверяется, что target тоже является 
    строковым типом и либо не является константным, либо идентичен literal. 
    \item Обработка типов BigInt: Если literal имеет тип BigIntType, проверяется, что target тоже является типом
    BigInt и либо не является константным, либо идентичен literal. 
    \item Далее происходит обработка большого (boxed) целевого типа:
    если target не является примитивным типом, значит он является объектом.
    Для случая объекта проверяется, является ли target большим типом.
    Если да, то target заменяется примитивным встроенным типом, полученным с помощью функции ToPrimitiveType.
    Если нет, возвращается false. 
    \item В итоге возвращается результат проверки идентичности literal и target на уровне классов анализатора или
    результат соответствия литерала целевому типу с помощью функции IsLiteralFitsToType
\end{itemize}

Стоит упомянуть принцип работы функции IsLiteralFitsToType.
Она берет значение литерала и напрямую сравнивает его с наименьшим и наибольшим значением target типа, используя функцию
стандартной библиотеки C++ std::numeric\_limits.

\subsubsection{Алгоритм отношения идентичности объединения другому типу}

Отношение идентичности определяет с каким другим объектом или типом наше объединение можно считать абсолютно идентичными.
Отношение идентичности для ссылочных типов означает, что у этих объектов одни и те же супертипы, один и тот же узел
AST дерева, задающий определение типа объекта, а также один и тот же набор типовых параметров и флагов.
Отношение идентичности для примитивных типов определяется равенством классов анализаторов (то есть и тот и другой
примитивный тип выражаются через IntType, например), а также равенством значений, если этот класс представляет собой
константу.

Для объединения был реализован свой алгоритм определения отношения идентичности, который можно разбить на две части:
идентичность в случае числового объединения и идентичность для объединения ссылочного типа.
Рассмотрим алгоритм, написанный на псевдокоде:

\begin{lstlisting}
Function Identical(thisType, otherType):
    if otherType is UnionType:
        if EachTypeIdenticalToSomeType(thisType, otherType) and
           EachTypeIdenticalToSomeType(otherType, thisType):
            return true
    if thisType.IsNumericUnion() and otherType is PrimitiveType:
        return Identical(thisType.lowLvlType, otherType)
    return false
\end{lstlisting}
Здесь thisType это наш тип объединения, который мы хотим проверить на идентичность другому типу.
Рассмотрим реализованные шаги подробнее:
\begin{itemize}
    \item Если otherType также является объединением, проверяется, что каждый тип в текущем union типе связан с
    каким-то типом в otherType и наоборот.
    Функция EachTypeIdenticalToSomeType используется для проверки этой связи.
    Если обе проверки выполняются, то типы считаются идентичными.
    \item Если текущий тип (thisType) является числовым union типом и otherType является примитивным типом
    (PrimitiveType), проверяется их идентичность с помощью низкоуровневого представления lowLvlType.

    lowLvlType подсчитывается при создании объединения, как было описано ранее.
    \item Если ни одно из условий не выполняется, возвращается результат отношения false.
\end{itemize}
Сравнение с низкоуровневым представлением вместо самого объединения связано с тем, что отношение идентичности для
примитивных типов и литералов слишком строгое и нам важно только то, каким типом будет являться наш union по факту
при кодировании в байт-код.

\subsubsection{Алгоритм отношения подтипирования}

Отношение подтипирования, как видно из названия, определяет, является ли один тип супертипом другого.
Для ссылочных типов рекурсивно проверяется, выполняется ли отношение идентичности между каким-либо супертипом другого
объекта и рассматриваемым ссылочным типом.
Подтипирование также выполняется и для идентичных типов.
Таким образом, отношение идентичности самое сильное из отношений, которое учитывается во всех остальных алгоритмах
отношений.
Для объединения был реализован свой метод, определяющий отношение подтипирования и заключается он в том, что
все компоненты union типа обходятся по порядку.
Для каждой составляющей объединения вызывается метод отношения IsSuperType(ct, other), где ct - это компонента union, а
other - потенциальный подтип.
В результате получается худющие правила подтипирования:
\begin{itemize}
    \item Объединение, состоящее из компонент \hl{($A_1$,. . . , $A_n$)} является подтипов другого объединения, состоящего
    из компонент \hl{($B_1$,. . . , $B_k$)}, если для каждого $B_i$ выполняется отношение подтипирования с $A_j$, то
    есть функция \hl{IsSuperType($A_j$, $B_i$)} возвращает истину для любых i и j.
    \item В частном порядке для объединений, состоящих из литеральных типов, следует, что отношение подтипирование
    возвращает истину только в том случае, если все литеральные типы одного объединения идентичны без явного
    приведения типов каким-либо компонентам из другого объединения.
\end{itemize}
Например, объединение \hl{1|2} является подтипом объединения \hl{1|2|3}, но не является подтипом объединения \hl{1|4},
так как для литералов 2 и 4 не выполняется отношение идентичности.

\subsubsection{Алгоритм отношения присвоения}

Отношение присвоения определяет, может ли какой-то тип быть присвоен объединению или наоборот.
Здесь могут учитываться контекст и неявные преобразования.

Функция RelationTarget является основной частью алгоритма и определяет, может ли источник (source) быть присвоен целевому
типу (this union type) в контексте отношений типов.
Это выполняется путем проверки, относится ли источник к одному из составляющих типов объединения.
Также учитывается необходимость применения boxing/unboxing преобразований.
Рассмотрим псевдокод этой функции:

\begin{lstlisting}[label={lst:relationtarget}]
Function RelationTarget(source):
    boxedSource = BoxType(source)
    if boxedSource != source and not ApplyBoxing():
        return false
    for each ct in ConstituentTypes:
        if IsAssignable(boxedSource, ct):
            if boxedSource != source:
                node.SetBoxingFlag(boxedSource)
            return true
    if boxedSource == source:
        return IsSupertype(thisUnion, boxedSource)
    related = false
    for each ct in ConstituentTypes:
        if IsAssignable(source, BoxType(ct)):
            if not IsNumericUnion():
                node.SetBoxingFlag(ct)
            related = true
    return related
\end{lstlisting}

Алгоритм может быть разбит на следующие шаги:

\begin{itemize}
    \item BoxType(source): Упаковываем тип источника, преобразуя его в соответствующий объектный тип
    (например, int к Integer).
    \item Если большой тип отличается от исходного и не требуется применять boxing, функция завершает выполнение.
    \item Далее проходим по всем типам, составляющим объединение и проверяем отношение присвоения boxed источника
    текущему типу из union.
    Если присвоение возможно, устанавливаем флаг boxing (если нужно) и возвращаем true.
    \item Если boxed источник совпадает с исходным, проверяем, является ли текущий union тип супертипом для источника.
    \item Далее инициализируем переменную related как false и проходим по всем типам, составляющим union.
    \item Внутри цикла проверяем, можно ли присвоить исходный источник текущему типу из union после упаковки.
    Если присвоение возможно, устанавливаем флаг boxing (если union тип не числовой) и устанавливаем related как true.
    \item В конечном счете возвращаем значение переменной related, указывающее на возможность присвоения.
\end{itemize}

Эта функция будет позже повторно использована для отношения приведения, так как это понятие очень близко к отношению
присвоения.
В результате она вызывается из другой функции присвоения, которая переопределяется для всех классов анализтора и
называется IsAssignable.

\subsubsection{Алгоритм отношения приведения}

Отношение приведения определяет, может ли наше объединение быть преобразовано в какой-либо другой тип с помощью
явного приведения.
В данной инфраструктуре компилятора, для каждого класса анализатора необходимо переопределить два метода приведения:
Cast и CastT\@.
Функция Cast определяет, можно ли явно привести рассматриваемый класс анализатора к какому-либо другой типу.
В свою очередь CastT действует наоборот и возвращает истину, если какой-либо другой тип может быть явно приведен
текущему классу анализатора.

Реализуем данные методы и отобразим их на языке псевдокода:

\begin{lstlisting}[label={lst:casttarget}]
Function Cast(target):
    If target is PrimitiveType:
        If not ApplyUnboxing():
            return false
        node.SetUnboxingFlag(target)
    If InCastingContext():
        For each ct in ConstituentTypes:
            If IsCastable(ct, target):
                return true
        return false
    If IsNumericUnion():
        return IsCastable(thisUnion.lowLvlType, target)
    res = true
    For each ct in ConstituentTypes:
        If not IsCastable(ct, target):
            res = false
            break
    return res
\end{lstlisting}

Этот метод описывает возможность приведения union типа к целевому типу.
Вот что происходит на каждом этапе:

\begin{itemize}
    \item Если целевой тип (target) является примитивным (PrimitiveType), проверяется возможность применения unboxing.
    Если unboxing невозможен (not ApplyUnboxing()), функция возвращает false.
    В противном случае устанавливается соответствующий флаг unboxing для узла AST дерева (node.SetUnboxingFlag(target)).
    \item Если функция вызвана в контексте приведения (InCastingContext()), проверяется возможность приведения
    каждой компоненты объединения (ct) к целевому типу (target).
    Если хотя бы один тип из составляющих типов union (ConstituentTypes) приводим к целевому типу, функция возвращает true.
    Если ни один из типов не приводим, функция возвращает false.
    \item Если union тип является числовым, проверяется возможность приведения его низкоуровневого представления к
    целевому типу.
    \item Если union тип не является числовым, проверяется возможность приведения каждой компоненты объединения
    к целевому типу.
    Если хотя бы одна компонента не приводима к target, то переменная res устанавливается в false и цикл прерывается.
    В конце функция возвращает значение res.
\end{itemize}

Пример использования:
предположим, что у нас есть union тип A | B | C, где A, B и C — это различные типы.
Нам нужно определить, может ли этот union тип быть приведен к другому типу T.
Функция Cast выполняет эту проверку, следуя описанным шагам, и возвращает true, если приведение возможно, и
false в противном случае.

Метод CastTarget работает точно таким же образом, что и Assignable, и вызывается внутри себя ту же функцию RelationTarget,
которая была описана ранее.
Единственная разница заключается в предикате для функции RelationTarget - в случае отношения присвоения этот предикат
проверяет Assignable каждой компоненты, а в случае отношения приведения - IsCastable.

\subsection{Кодогенерация объединений}

В данном разделе будут описаны различные алгоритмы кодогенерации для объединений, а также различные реализованные
проходы компилятора, которые позволяют модифицировать AST дерево и подготовить его к дальнейшим преобразованиям.

\subsubsection{Алгоритм понижения доступа к полю}

\subsubsection{Алгоритм понижения оператора ==}

\subsection{Оптимизация объединений}


\newpage
