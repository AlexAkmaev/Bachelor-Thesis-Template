\section{Постановка задачи}
\label{sec:Chapter1} \index{Chapter1}

\subsection{Проблематика}

Как уже было сказано ранее, разработка качественных и многократно используемых библиотек это довольно сложная задача.
Объединения или union типы в статически типизированных языках решают эту и несколько других значимых проблем.
Позволяя переменной хранить значение, которое может быть одним из нескольких указанных типов, объединения повышают
безопасность типов, гибкость и выразительность кода, сохраняя при этом преимущества статической проверки типов.
Кроме того, перед нашим статическим языком стоит проблема максимальной совместимости с TypeScript.
Поскольку union типы часто используются в TS, например в nullish типах или опциональных полях классов и параметрах
функций, необходимо реализовать ту же функциональность и в MyTS.

\subsection{Цель работы}

Поддержать union типы на уровне компилятора, при этом соответствуя синтаксису и семантике TypeScript.

\subsection{Задачи}

\begin{itemize}[left=2em]
    \item Спроектировать и реализовать класс для базовых union типов

    (let x: A|B = new A())
    \item Поддержать доступ к общим полям всех составляющих
    \item Реализовать нормализацию типов, входящих в объединение
    \item Перенести необходимый функционал в lowering фазу
    \item Поддержать литералы в качестве составляющих объединения
    \item Оптимизировать AST дерево с целью уменьшения байткода или ускорения рантайма
\end{itemize}

\subsection{Обработка результатов}

\begin{itemize}[left=2em]
    \item Обеспечить достаточное покрытие тестами
    \item Убедиться, что процент пройденных тестов больше 80
    \item Привести наглядные графики результатов оптимизации
\end{itemize}

\subsection{Требования}

\begin{itemize}[left=2em]
    \item Соответствовать спецификации языка MyTS
    \item Генерировать валидный байткод
    \item Не допускать просадки перформанса во время исполнения
\end{itemize}

\newpage
